#!/usr/bin/env python3
"""
RAG Knowledge Management Web Interface - ä¼˜åŒ–ç‰ˆ
æä¾›çŸ¥è¯†åº“ç®¡ç†å’ŒæŸ¥è¯¢çš„Webç•Œé¢ï¼Œè¿è¡Œåœ¨ç«¯å£4000
ä¸rag.pyæœåŠ¡(ç«¯å£8001)åä½œ
"""
import os
import json
import asyncio
import aiofiles
import aiohttp
import hashlib
import uuid
from pathlib import Path
from datetime import datetime
from typing import List, Optional

from fastapi import FastAPI, HTTPException, UploadFile, File, Form, BackgroundTasks
from fastapi.staticfiles import StaticFiles
from fastapi.responses import HTMLResponse, JSONResponse
from pydantic import BaseModel
import uvicorn

# åº”ç”¨é…ç½®
app = FastAPI(title="RAG Knowledge Management Web Interface", version="1.1.0")

# é…ç½®ç›®å½•
BASE_DIR = Path(__file__).parent
STATIC_DIR = BASE_DIR / "static"
UPLOADS_DIR = BASE_DIR / "uploads"
KNOWLEDGE_BASES_DIR = BASE_DIR / "knowledge_bases"

# ç¡®ä¿ç›®å½•å­˜åœ¨
for dir_path in [UPLOADS_DIR, KNOWLEDGE_BASES_DIR]:
    dir_path.mkdir(parents=True, exist_ok=True)

# æŒ‚è½½é™æ€æ–‡ä»¶
app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")

# ğŸ”§ RAGæœåŠ¡é…ç½® - åŒ¹é…ä½ çš„rag.pyè®¾ç½®
RAG_SERVICE_URL = "http://localhost:8001"
RAG_HEALTH_URL = f"{RAG_SERVICE_URL}/health"
RAG_QUERY_URL = f"{RAG_SERVICE_URL}/api/query"
RAG_INSERT_URL = f"{RAG_SERVICE_URL}/api/insert"
RAG_PARSE_DOCUMENT_URL = f"{RAG_SERVICE_URL}/api/parse-document"
RAG_PROGRESS_URL = f"{RAG_SERVICE_URL}/api/progress"

# æ•°æ®æ¨¡å‹
class QueryRequest(BaseModel):
    query: str
    mode: str = "hybrid"
    
class QueryResponse(BaseModel):
    status: str
    result: str
    mode: str
    timestamp: datetime

class KnowledgeBase(BaseModel):
    name: str
    description: str = ""
    
class FileInfo(BaseModel):
    filename: str
    size: int
    upload_time: datetime
    status: str = "uploaded"  # uploaded, processing, completed, error
    progress: int = 0
    knowledge_base: str

# å…¨å±€çŠ¶æ€ç®¡ç†
knowledge_bases = {}
file_status = {}

# å¯åŠ¨æ—¶åŠ è½½å·²å­˜åœ¨çš„çŸ¥è¯†åº“å’Œæ–‡ä»¶
def load_existing_knowledge_bases():
    """ä»æ–‡ä»¶ç³»ç»ŸåŠ è½½å·²å­˜åœ¨çš„çŸ¥è¯†åº“"""
    if KNOWLEDGE_BASES_DIR.exists():
        for kb_dir in KNOWLEDGE_BASES_DIR.iterdir():
            if kb_dir.is_dir():
                knowledge_bases[kb_dir.name] = {
                    "name": kb_dir.name,
                    "description": "",
                    "created_time": datetime.fromtimestamp(kb_dir.stat().st_ctime),
                    "file_count": len(list(kb_dir.glob("*"))),
                    "path": str(kb_dir)
                }
                print(f"ğŸ“‚ åŠ è½½çŸ¥è¯†åº“: {kb_dir.name}")

def load_existing_files():
    """ä»ä¸Šä¼ ç›®å½•åŠ è½½å·²å­˜åœ¨çš„æ–‡ä»¶"""
    if UPLOADS_DIR.exists():
        for file_path in UPLOADS_DIR.glob("*"):
            if file_path.is_file():
                filename = file_path.name
                if "_" in filename:
                    kb_name = filename.split("_")[0]
                    file_info = {
                        "filename": filename,
                        "safe_filename": filename,
                        "size": file_path.stat().st_size,
                        "upload_time": datetime.fromtimestamp(file_path.stat().st_ctime),
                        "status": "uploaded",
                        "progress": 0,
                        "knowledge_base": kb_name,
                        "file_path": str(file_path)
                    }
                    file_status[filename] = file_info
                    print(f"ğŸ“„ åŠ è½½æ–‡ä»¶: {filename}")

# åº”ç”¨å¯åŠ¨æ—¶æ‰§è¡Œ
load_existing_knowledge_bases()
load_existing_files()

async def check_rag_service_health():
    """æ£€æŸ¥RAGæœåŠ¡æ˜¯å¦å¯ç”¨"""
    try:
        timeout = aiohttp.ClientTimeout(total=5)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            async with session.get(RAG_HEALTH_URL) as response:
                if response.status == 200:
                    data = await response.json()
                    print(f"âœ… RAGæœåŠ¡å¥åº·æ£€æŸ¥é€šè¿‡: {data}")
                    return True, data
                else:
                    print(f"âŒ RAGæœåŠ¡å¥åº·æ£€æŸ¥å¤±è´¥: {response.status}")
                    return False, f"HTTP {response.status}"
    except Exception as e:
        print(f"âŒ RAGæœåŠ¡è¿æ¥å¤±è´¥: {e}")
        return False, str(e)

@app.on_event("startup")
async def startup_event():
    """åº”ç”¨å¯åŠ¨æ—¶æ£€æŸ¥RAGæœåŠ¡"""
    print("ğŸš€ Webç•Œé¢å¯åŠ¨ä¸­...")
    
    # ç»™RAGæœåŠ¡ä¸€äº›å¯åŠ¨æ—¶é—´
    print("â³ ç­‰å¾…RAGæœåŠ¡å¯åŠ¨...")
    await asyncio.sleep(2)
    
    health_ok, health_info = await check_rag_service_health()
    if health_ok:
        print("âœ… RAGæœåŠ¡è¿æ¥æ­£å¸¸")
        print(f"ğŸ“Š RAGæœåŠ¡çŠ¶æ€: {health_info}")
    else:
        print(f"âš ï¸ RAGæœåŠ¡æœªå°±ç»ª: {health_info}")
        print("ğŸ’¡ è¯·ç¡®ä¿ rag.py æœåŠ¡æ­£åœ¨è¿è¡Œ: python rag.py")

@app.get("/", response_class=HTMLResponse)
async def read_root():
    """è¿”å›ä¸»é¡µé¢"""
    html_file = STATIC_DIR / "index.html"
    if html_file.exists():
        async with aiofiles.open(html_file, 'r', encoding='utf-8') as f:
            content = await f.read()
        return HTMLResponse(content=content)
    else:
        return HTMLResponse(content="""
        <html><body>
        <h1>RAG Knowledge Management System</h1>
        <p>é™æ€æ–‡ä»¶æœªæ‰¾åˆ°ï¼Œè¯·æ£€æŸ¥ static/index.html</p>
        </body></html>
        """)

@app.get("/health")
async def health_check():
    """å¥åº·æ£€æŸ¥"""
    try:
        # æ£€æŸ¥RAGæœåŠ¡çŠ¶æ€
        rag_healthy, rag_info = await check_rag_service_health()
        
        return {
            "status": "healthy",
            "service": "rag-web-interface",
            "port": 4000,
            "rag_service": {
                "healthy": rag_healthy,
                "info": rag_info,
                "url": RAG_SERVICE_URL
            },
            "knowledge_bases": len(knowledge_bases),
            "total_files": len(file_status),
        }
    except Exception as e:
        return {
            "status": "error",
            "service": "rag-web-interface",
            "error": str(e)
        }

@app.get("/api/knowledge-bases")
async def list_knowledge_bases():
    """è·å–çŸ¥è¯†åº“åˆ—è¡¨"""
    return {"knowledge_bases": list(knowledge_bases.values())}

@app.post("/api/knowledge-bases")
async def create_knowledge_base(kb: KnowledgeBase):
    """åˆ›å»ºæ–°çš„çŸ¥è¯†åº“"""
    if kb.name in knowledge_bases:
        raise HTTPException(status_code=400, detail="Knowledge base already exists")
    
    kb_dir = KNOWLEDGE_BASES_DIR / kb.name
    kb_dir.mkdir(exist_ok=True)
    
    knowledge_bases[kb.name] = {
        "name": kb.name,
        "description": kb.description,
        "created_time": datetime.now(),
        "file_count": 0,
        "path": str(kb_dir)
    }
    
    return {"status": "success", "message": f"Knowledge base '{kb.name}' created"}

@app.get("/api/files")
async def list_files(knowledge_base: Optional[str] = None):
    """è·å–æ–‡ä»¶åˆ—è¡¨"""
    if knowledge_base:
        filtered_files = {k: v for k, v in file_status.items() 
                         if v.get("knowledge_base") == knowledge_base}
        return {"files": list(filtered_files.values())}
    return {"files": list(file_status.values())}

@app.post("/api/upload")
async def upload_files(
    background_tasks: BackgroundTasks,
    files: List[UploadFile] = File(...),
    knowledge_base: str = Form(...)
):
    """ä¸Šä¼ æ–‡ä»¶åˆ°æŒ‡å®šçŸ¥è¯†åº“"""
    print(f"ğŸ“¤ æ”¶åˆ°ä¸Šä¼ è¯·æ±‚: çŸ¥è¯†åº“={knowledge_base}, æ–‡ä»¶æ•°={len(files)}")
    
    if knowledge_base not in knowledge_bases:
        print(f"âŒ çŸ¥è¯†åº“ä¸å­˜åœ¨: {knowledge_base}")
        raise HTTPException(status_code=400, detail=f"çŸ¥è¯†åº“ '{knowledge_base}' ä¸å­˜åœ¨ï¼Œè¯·å…ˆåˆ›å»ºçŸ¥è¯†åº“")
    
    uploaded_files = []
    
    try:
        for file in files:
            print(f"ğŸ“„ å¤„ç†æ–‡ä»¶: {file.filename}")
            
            file_ext = Path(file.filename).suffix
            safe_filename = f"{knowledge_base}_{uuid.uuid4().hex[:8]}{file_ext}"
            file_path = UPLOADS_DIR / safe_filename
            
            async with aiofiles.open(file_path, 'wb') as f:
                content = await file.read()
                await f.write(content)
            
            file_info = {
                "filename": file.filename,
                "safe_filename": safe_filename,
                "size": len(content),
                "upload_time": datetime.now(),
                "status": "uploaded",
                "progress": 0,
                "knowledge_base": knowledge_base,
                "file_path": str(file_path)
            }
            
            file_status[safe_filename] = file_info
            uploaded_files.append(file_info)
            print(f"âœ… æ–‡ä»¶ä¸Šä¼ æˆåŠŸ: {file.filename}")
            
    except Exception as e:
        print(f"âŒ ä¸Šä¼ å¤±è´¥: {e}")
        raise HTTPException(status_code=500, detail=f"æ–‡ä»¶ä¸Šä¼ å¤±è´¥: {str(e)}")
    
    knowledge_bases[knowledge_base]["file_count"] += len(uploaded_files)
    
    return {
        "status": "success", 
        "uploaded_files": len(uploaded_files),
        "files": [
            {
                "filename": info["filename"],
                "safe_filename": info["safe_filename"],
                "size": info["size"],
                "status": info["status"],
                "progress": info["progress"],
                "knowledge_base": info["knowledge_base"],
                "upload_time": info["upload_time"].isoformat()
            }
            for info in uploaded_files
        ]
    }

@app.post("/api/parse")
async def start_parsing(
    background_tasks: BackgroundTasks,
    filename: str = Form(...),
    knowledge_base: str = Form(...)
):
    """å¼€å§‹è§£ææŒ‡å®šæ–‡ä»¶"""
    print(f"ğŸ” æ”¶åˆ°è§£æè¯·æ±‚: filename={filename}, kb={knowledge_base}")
    
    file_key = None
    for key, file_info in file_status.items():
        if (file_info.get("filename") == filename and 
            file_info.get("knowledge_base") == knowledge_base):
            file_key = key
            break
    
    if file_key is None:
        print(f"âŒ æ–‡ä»¶æœªæ‰¾åˆ°: {filename}")
        raise HTTPException(status_code=404, detail=f"File not found: {filename}")
    
    # ğŸ”§ ä¼˜åŒ–ï¼šå…ˆæ£€æŸ¥RAGæœåŠ¡çŠ¶æ€
    rag_healthy, rag_info = await check_rag_service_health()
    if not rag_healthy:
        raise HTTPException(
            status_code=503, 
            detail=f"RAGæœåŠ¡ä¸å¯ç”¨: {rag_info}ã€‚è¯·ç¡®ä¿ rag.py æœåŠ¡æ­£åœ¨è¿è¡Œã€‚"
        )
    
    # åˆå§‹åŒ–çŠ¶æ€
    file_status[file_key]["status"] = "processing"
    file_status[file_key]["progress"] = 0
    file_status[file_key]["error"] = None
    print(f"ğŸ“Š åˆå§‹åŒ–çŠ¶æ€: {file_key} -> processing, progress=0%")
    
    # å¯åŠ¨åå°è§£æä»»åŠ¡
    background_tasks.add_task(process_file_parsing_optimized, file_key)
    
    return {"status": "success", "message": f"Started parsing {filename}"}

async def process_file_parsing_optimized(file_key: str):
    """ä¼˜åŒ–ç‰ˆçš„åå°æ–‡ä»¶è§£æä»»åŠ¡"""
    try:
        print(f"ğŸ”„ å¼€å§‹è§£ææ–‡ä»¶: {file_key}")
        file_info = file_status[file_key]
        file_path = file_info["file_path"]
        knowledge_base_name = file_info["knowledge_base"]
        
        # æ·»åŠ å°å»¶è¿Ÿç¡®ä¿å‰ç«¯èƒ½çœ‹åˆ°åˆå§‹çŠ¶æ€
        await asyncio.sleep(0.5)
        
        # çœŸå®è¿›åº¦è·Ÿè¸ª
        file_status[file_key]["progress"] = 10
        print(f"ğŸ“Š è¿›åº¦æ›´æ–°: {file_key} -> 10% (éªŒè¯æ–‡ä»¶å­˜åœ¨)")
        await asyncio.sleep(1)
        
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨
        if not Path(file_path).exists():
            raise Exception(f"æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
        
        file_status[file_key]["progress"] = 30
        print(f"ğŸ“Š è¿›åº¦æ›´æ–°: {file_key} -> 30% (æ–‡ä»¶éªŒè¯å®Œæˆï¼Œå‡†å¤‡å‘é€ç»™RAGæœåŠ¡)")
        await asyncio.sleep(1)
        
        file_status[file_key]["progress"] = 50
        print(f"ğŸ“Š è¿›åº¦æ›´æ–°: {file_key} -> 50% (å‡†å¤‡è°ƒç”¨RAGæœåŠ¡è¿›è¡Œæ–‡æ¡£å¤„ç†)")
        await asyncio.sleep(1)
        
        # ğŸ”§ è°ƒç”¨RAGæœåŠ¡çš„æ–‡æ¡£å¤„ç†æ¥å£
        file_status[file_key]["progress"] = 70
        print(f"ğŸ“Š è¿›åº¦æ›´æ–°: {file_key} -> 70% (æ­£åœ¨å‘é€åˆ°RAGæœåŠ¡è¿›è¡Œæ–‡æ¡£å¤„ç†)")
        
        # å‡†å¤‡æ–‡æ¡£å¤„ç†çš„payload
        payload = {
            "file_path": file_path,
            "knowledge_base": knowledge_base_name,
            "parse_method": "auto",
            "display_stats": True
        }
        
        print(f"ğŸ“¤ å‘é€åˆ°RAGæœåŠ¡è¿›è¡Œæ–‡æ¡£å¤„ç†:")
        print(f"   - æ–‡ä»¶å: {file_info['filename']}")
        print(f"   - æ–‡ä»¶è·¯å¾„: {file_path}")
        print(f"   - çŸ¥è¯†åº“: {knowledge_base_name}")
        print(f"   - RAGæœåŠ¡URL: {RAG_PARSE_DOCUMENT_URL}")
        
        # ğŸ”§ ä¼˜åŒ–çš„HTTPè¯·æ±‚è®¾ç½® - å¤§æ–‡æ¡£å¤„ç†è®¾ç½®4å°æ—¶è¶…æ—¶
        timeout = aiohttp.ClientTimeout(total=14400, connect=60)  # 4å°æ—¶æ€»è¶…æ—¶ï¼Œ60ç§’è¿æ¥è¶…æ—¶
        async with aiohttp.ClientSession(timeout=timeout) as session:
            try:
                async with session.post(RAG_PARSE_DOCUMENT_URL, json=payload) as response:
                    response_status = response.status
                    response_text = await response.text()
                    
                    print(f"ğŸ“¥ RAGæœåŠ¡å“åº”: çŠ¶æ€ç ={response_status}")
                    print(f"ğŸ“¥ RAGæœåŠ¡å“åº”å†…å®¹: {response_text[:500]}...")
                    
                    if response_status == 200:
                        try:
                            response_data = json.loads(response_text)
                            print(f"âœ… RAGæœåŠ¡å“åº”æ•°æ®: {response_data}")
                        except json.JSONDecodeError:
                            print(f"âš ï¸ RAGæœåŠ¡å“åº”ä¸æ˜¯JSONæ ¼å¼ï¼Œå†…å®¹: {response_text}")
                        
                        file_status[file_key]["progress"] = 90
                        print(f"ğŸ“Š è¿›åº¦æ›´æ–°: {file_key} -> 90% (RAGæœåŠ¡å¤„ç†å®Œæˆ)")
                        await asyncio.sleep(1)
                        
                        # ğŸ”§ éªŒè¯æ–‡æ¡£å¤„ç†ç»“æœ
                        verification_result = await verify_insertion_advanced(
                            knowledge_base_name, 
                            file_info["filename"], 
                            file_info["filename"].split('.')[0]  # ä½¿ç”¨æ–‡ä»¶åï¼ˆå»æ‰æ‰©å±•åï¼‰ä½œä¸ºæŸ¥è¯¢è¯
                        )
                        
                        if verification_result:
                            print(f"âœ… æ–‡æ¡£å¤„ç†éªŒè¯æˆåŠŸ: å¯ä»¥æŸ¥è¯¢åˆ°æ–‡æ¡£å†…å®¹")
                            file_status[file_key]["status"] = "completed"
                            file_status[file_key]["progress"] = 100
                            print(f"âœ… æ–‡æ¡£å¤„ç†æˆåŠŸ: {file_key} -> 100% (å…¨éƒ¨å®Œæˆ)")
                        else:
                            print(f"âš ï¸ æ–‡æ¡£å¤„ç†éªŒè¯å¤±è´¥: æ— æ³•æŸ¥è¯¢åˆ°æ–‡æ¡£å†…å®¹")
                            file_status[file_key]["status"] = "completed"  # ä»æ ‡è®°å®Œæˆï¼Œå› ä¸ºå¤„ç†APIæˆåŠŸäº†
                            file_status[file_key]["progress"] = 100
                            file_status[file_key]["error"] = "æ–‡æ¡£å¤„ç†æˆåŠŸä½†éªŒè¯æŸ¥è¯¢æœªé€šè¿‡ï¼Œå¯èƒ½éœ€è¦ç­‰å¾…ç´¢å¼•å®Œæˆ"
                        
                    else:
                        error_msg = f"RAGæœåŠ¡é”™è¯¯: HTTP {response_status} - {response_text}"
                        print(f"âŒ RAGæ–‡æ¡£å¤„ç†å¤±è´¥: {error_msg}")
                        file_status[file_key]["status"] = "error"
                        file_status[file_key]["progress"] = 0
                        file_status[file_key]["error"] = error_msg
                        
            except asyncio.TimeoutError:
                error_msg = "RAGæœåŠ¡è¯·æ±‚è¶…æ—¶ (10åˆ†é’Ÿ)"
                print(f"âŒ {error_msg}")
                file_status[file_key]["status"] = "error"
                file_status[file_key]["progress"] = 0
                file_status[file_key]["error"] = error_msg
            except aiohttp.ClientError as e:
                error_msg = f"è¿æ¥RAGæœåŠ¡å¤±è´¥: {str(e)}"
                print(f"âŒ {error_msg}")
                file_status[file_key]["status"] = "error"
                file_status[file_key]["progress"] = 0
                file_status[file_key]["error"] = error_msg
                
    except Exception as e:
        error_msg = f"è§£æå¼‚å¸¸: {str(e)}"
        print(f"âŒ {error_msg}")
        file_status[file_key]["status"] = "error"
        file_status[file_key]["progress"] = 0
        file_status[file_key]["error"] = error_msg
        
        import traceback
        traceback.print_exc()

async def read_file_with_multiple_encodings(file_path: str) -> str:
    """å¤šç¼–ç æ–¹å¼è¯»å–æ–‡ä»¶"""
    encodings = ['utf-8', 'gbk', 'gb2312', 'utf-16', 'latin1']
    
    for encoding in encodings:
        try:
            async with aiofiles.open(file_path, 'r', encoding=encoding) as f:
                content = await f.read()
                print(f"âœ… æˆåŠŸä½¿ç”¨ {encoding} ç¼–ç è¯»å–æ–‡ä»¶")
                return content
        except (UnicodeDecodeError, UnicodeError):
            print(f"âš ï¸ {encoding} ç¼–ç è¯»å–å¤±è´¥ï¼Œå°è¯•ä¸‹ä¸€ä¸ª...")
            continue
    
    # æœ€åå°è¯•äºŒè¿›åˆ¶è¯»å–
    try:
        async with aiofiles.open(file_path, 'rb') as f:
            raw_content = await f.read()
            content = raw_content.decode('utf-8', errors='ignore')
            print(f"âœ… ä½¿ç”¨äºŒè¿›åˆ¶+å¿½ç•¥é”™è¯¯æ¨¡å¼è¯»å–æ–‡ä»¶")
            return content
    except Exception as e:
        raise Exception(f"æ— æ³•è¯»å–æ–‡ä»¶ {file_path}: {e}")

async def verify_insertion_advanced(knowledge_base: str, filename: str, content_sample: str):
    """é«˜çº§æ’å…¥éªŒè¯"""
    try:
        print(f"ğŸ” éªŒè¯æ’å…¥: çŸ¥è¯†åº“={knowledge_base}, æ–‡ä»¶={filename}")
        
        # ç­‰å¾…ä¸€å®šæ—¶é—´è®©RAGæœåŠ¡å®Œæˆç´¢å¼•
        await asyncio.sleep(3)
        
        # å‡†å¤‡å¤šç§æŸ¥è¯¢è¯è¿›è¡ŒéªŒè¯
        test_queries = []
        
        # 1. ä½¿ç”¨æ–‡ä»¶åï¼ˆå»æ‰æ‰©å±•åï¼‰
        if filename:
            base_name = filename.split('.')[0]
            if len(base_name) > 3:
                test_queries.append(base_name[:20])
        
        # 2. ä½¿ç”¨å†…å®¹çš„å…³é”®è¯
        if content_sample and len(content_sample) > 10:
            # ç®€å•æå–ä¸€äº›å¯èƒ½çš„å…³é”®è¯
            words = content_sample.split()
            if len(words) >= 3:
                test_queries.append(' '.join(words[:3]))
            test_queries.append(content_sample[:30])
        
        if not test_queries:
            test_queries = ["æµ‹è¯•æŸ¥è¯¢"]
        
        print(f"ğŸ” æµ‹è¯•æŸ¥è¯¢è¯: {test_queries}")
        
        # å°è¯•ä¸åŒçš„æŸ¥è¯¢æ¨¡å¼
        for query in test_queries[:2]:  # æœ€å¤šæµ‹è¯•2ä¸ªæŸ¥è¯¢è¯
            for mode in ["naive", "hybrid"]:
                try:
                    payload = {
                        "query": query,
                        "mode": mode
                    }
                    
                    timeout = aiohttp.ClientTimeout(total=30)
                    async with aiohttp.ClientSession(timeout=timeout) as session:
                        async with session.post(RAG_QUERY_URL, json=payload) as response:
                            if response.status == 200:
                                response_text = await response.text()
                                try:
                                    response_data = json.loads(response_text)
                                    result_data = response_data.get('data', response_text)
                                except json.JSONDecodeError:
                                    result_data = response_text
                                
                                print(f"ğŸ” éªŒè¯æŸ¥è¯¢å“åº” ({mode}): {str(result_data)[:200]}...")
                                
                                # æ£€æŸ¥å“åº”ä¸­æ˜¯å¦åŒ…å«ç›¸å…³å†…å®¹
                                result_str = str(result_data).lower()
                                query_lower = query.lower()
                                
                                if (query_lower in result_str or 
                                    len(result_str.strip()) > 50):  # å¦‚æœæœ‰å®è´¨æ€§çš„å“åº”
                                    print(f"âœ… éªŒè¯æˆåŠŸ: æŸ¥è¯¢ '{query}' ({mode}) è¿”å›äº†ç›¸å…³å†…å®¹")
                                    return True
                                else:
                                    print(f"âš ï¸ æŸ¥è¯¢ '{query}' ({mode}) æœªè¿”å›é¢„æœŸå†…å®¹")
                            else:
                                print(f"âŒ éªŒè¯æŸ¥è¯¢å¤±è´¥: {response.status}")
                                
                except Exception as e:
                    print(f"âŒ éªŒè¯æŸ¥è¯¢å¼‚å¸¸: {e}")
                    continue
        
        print(f"âŒ æ‰€æœ‰éªŒè¯æŸ¥è¯¢éƒ½æœªé€šè¿‡")
        return False
        
    except Exception as e:
        print(f"âŒ éªŒè¯å¼‚å¸¸: {e}")
        return False

@app.get("/api/files/{file_key}/status")
async def get_file_status(file_key: str):
    """è·å–æ–‡ä»¶è§£æçŠ¶æ€"""
    print(f"ğŸ” æŸ¥è¯¢æ–‡ä»¶çŠ¶æ€: {file_key}")
    
    # é¦–å…ˆå°è¯•ç›´æ¥åŒ¹é…
    if file_key in file_status:
        print(f"ğŸ“‹ æ‰¾åˆ°æ–‡ä»¶çŠ¶æ€: {file_key}")
        return file_status[file_key]
    
    # å°è¯•é€šè¿‡safe_filenameå­—æ®µåŒ¹é…
    for key, file_info in file_status.items():
        if file_info.get("safe_filename") == file_key:
            return file_info
    
    # URLè§£ç åŒ¹é…
    import urllib.parse
    try:
        decoded_file_key = urllib.parse.unquote(file_key)
        if decoded_file_key in file_status:
            return file_status[decoded_file_key]
    except Exception:
        pass
    
    print(f"âŒ æ–‡ä»¶æœªæ‰¾åˆ°: {file_key}")
    raise HTTPException(status_code=404, detail=f"File not found: {file_key}")

# ğŸ”§ æ–°å¢ï¼šæ–‡ä»¶çŠ¶æ€é‡ç½®æ¥å£ï¼Œç”¨äºè°ƒè¯•
@app.post("/api/files/{file_key}/reset")
async def reset_file_status(file_key: str):
    """é‡ç½®æ–‡ä»¶çŠ¶æ€ä¸ºuploadedï¼ˆç”¨äºè°ƒè¯•ï¼‰"""
    if file_key in file_status:
        file_status[file_key]["status"] = "uploaded"
        file_status[file_key]["progress"] = 0
        file_status[file_key]["error"] = None
        return {"status": "success", "message": f"File {file_key} status reset"}
    else:
        raise HTTPException(status_code=404, detail=f"File not found: {file_key}")

# ğŸ”§ æ–°å¢ï¼šåˆ é™¤æ–‡ä»¶æ¥å£
@app.delete("/api/files/{file_key}")
async def delete_file(file_key: str):
    """åˆ é™¤æŒ‡å®šæ–‡ä»¶"""
    print(f"ğŸ—‘ï¸ æ”¶åˆ°åˆ é™¤è¯·æ±‚: {file_key}")
    
    # æŸ¥æ‰¾æ–‡ä»¶
    file_info = None
    if file_key in file_status:
        file_info = file_status[file_key]
    else:
        # å°è¯•é€šè¿‡safe_filenameåŒ¹é…
        for key, info in file_status.items():
            if info.get("safe_filename") == file_key:
                file_key = key
                file_info = info
                break
    
    if not file_info:
        print(f"âŒ æ–‡ä»¶æœªæ‰¾åˆ°: {file_key}")
        raise HTTPException(status_code=404, detail=f"File not found: {file_key}")
    
    try:
        # åˆ é™¤ç‰©ç†æ–‡ä»¶
        file_path = Path(file_info["file_path"])
        if file_path.exists():
            file_path.unlink()
            print(f"âœ… åˆ é™¤ç‰©ç†æ–‡ä»¶: {file_path}")
        else:
            print(f"âš ï¸ ç‰©ç†æ–‡ä»¶ä¸å­˜åœ¨: {file_path}")
        
        # ä»å†…å­˜çŠ¶æ€ä¸­åˆ é™¤
        original_filename = file_info["filename"]
        knowledge_base = file_info["knowledge_base"]
        del file_status[file_key]
        print(f"âœ… åˆ é™¤å†…å­˜è®°å½•: {file_key}")
        
        # æ›´æ–°çŸ¥è¯†åº“æ–‡ä»¶è®¡æ•°
        if knowledge_base in knowledge_bases:
            knowledge_bases[knowledge_base]["file_count"] = max(0, knowledge_bases[knowledge_base]["file_count"] - 1)
        
        return {
            "status": "success", 
            "message": f"æ–‡ä»¶ {original_filename} åˆ é™¤æˆåŠŸ",
            "deleted_file": original_filename
        }
        
    except Exception as e:
        print(f"âŒ åˆ é™¤æ–‡ä»¶å¤±è´¥: {e}")
        raise HTTPException(status_code=500, detail=f"åˆ é™¤æ–‡ä»¶å¤±è´¥: {str(e)}")

@app.post("/api/query")
async def query_knowledge_base(request: QueryRequest):
    """æŸ¥è¯¢çŸ¥è¯†åº“"""
    try:
        print(f"ğŸ” æ”¶åˆ°æŸ¥è¯¢è¯·æ±‚: {request.query[:50]}... (mode: {request.mode})")
        
        # æ£€æŸ¥RAGæœåŠ¡çŠ¶æ€
        rag_healthy, rag_info = await check_rag_service_health()
        if not rag_healthy:
            raise HTTPException(
                status_code=503, 
                detail=f"RAGæœåŠ¡ä¸å¯ç”¨: {rag_info}"
            )
        
        # è½¬å‘æŸ¥è¯¢è¯·æ±‚åˆ°RAGæœåŠ¡
        payload = {
            "query": request.query,
            "mode": request.mode
        }
        
        timeout = aiohttp.ClientTimeout(total=60)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            async with session.post(RAG_QUERY_URL, json=payload) as response:
                response_status = response.status
                response_text = await response.text()
                
                if response_status == 200:
                    try:
                        response_data = json.loads(response_text)
                        result = response_data.get('data', response_text)
                        print(f"âœ… æŸ¥è¯¢å®Œæˆï¼Œç»“æœé•¿åº¦: {len(str(result))}")
                        
                        return QueryResponse(
                            status="success",
                            result=str(result) if result else "æœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯",
                            mode=request.mode,
                            timestamp=datetime.now()
                        )
                    except json.JSONDecodeError:
                        # å¦‚æœå“åº”ä¸æ˜¯JSONï¼Œç›´æ¥è¿”å›æ–‡æœ¬
                        print(f"âœ… æŸ¥è¯¢å®Œæˆï¼Œè¿”å›æ–‡æœ¬ç»“æœ")
                        return QueryResponse(
                            status="success",
                            result=response_text if response_text else "æœªæ‰¾åˆ°ç›¸å…³ä¿¡æ¯",
                            mode=request.mode,
                            timestamp=datetime.now()
                        )
                else:
                    error_msg = f"RAGæŸ¥è¯¢å¤±è´¥: HTTP {response_status} - {response_text}"
                    print(f"âŒ {error_msg}")
                    raise HTTPException(status_code=500, detail=error_msg)
                    
    except aiohttp.ClientError as e:
        error_msg = f"è¿æ¥RAGæœåŠ¡å¤±è´¥: {str(e)}"
        print(f"âŒ {error_msg}")
        raise HTTPException(status_code=503, detail=error_msg)
    except Exception as e:
        print(f"âŒ æŸ¥è¯¢å¼‚å¸¸: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail=f"æŸ¥è¯¢å¤±è´¥: {str(e)}")

# ğŸ”§ è°ƒè¯•APIæ¥å£
@app.get("/api/rag-service-status")
async def detailed_rag_service_status():
    """è¯¦ç»†çš„RAGæœåŠ¡çŠ¶æ€æ£€æŸ¥"""
    results = {}
    
    # æµ‹è¯•ä¸åŒçš„ç«¯ç‚¹
    test_endpoints = [
        {"name": "health_check", "url": f"{RAG_SERVICE_URL}/health", "method": "GET"},
        {"name": "query_test", "url": f"{RAG_SERVICE_URL}/api/query", "method": "POST", 
         "payload": {"query": "æµ‹è¯•", "mode": "naive"}},
    ]
    
    for endpoint in test_endpoints:
        try:
            timeout = aiohttp.ClientTimeout(total=10)
            async with aiohttp.ClientSession(timeout=timeout) as session:
                if endpoint["method"] == "GET":
                    async with session.get(endpoint["url"]) as response:
                        status = response.status
                        data = await response.text()
                        results[endpoint["name"]] = {
                            "url": endpoint["url"],
                            "status": status,
                            "response": data[:300],
                            "success": status == 200
                        }
                else:  # POST
                    async with session.post(endpoint["url"], json=endpoint["payload"]) as response:
                        status = response.status
                        data = await response.text()
                        results[endpoint["name"]] = {
                            "url": endpoint["url"],
                            "status": status,
                            "response": data[:300],
                            "success": status == 200,
                            "payload": endpoint["payload"]
                        }
        except Exception as e:
            results[endpoint["name"]] = {
                "url": endpoint["url"],
                "error": str(e),
                "success": False
            }
    
    return {
        "rag_service_url": RAG_SERVICE_URL,
        "test_results": results,
        "summary": {
            "total_tests": len(test_endpoints),
            "successful_tests": sum(1 for r in results.values() if r.get("success", False)),
            "all_tests_passed": all(r.get("success", False) for r in results.values())
        }
    }

@app.post("/api/manual-test-insert")
async def manual_test_insert():
    """æ‰‹åŠ¨æµ‹è¯•RAGæ’å…¥åŠŸèƒ½"""
    test_content = f"""æ‰‹åŠ¨æµ‹è¯•æ–‡æ¡£ - {datetime.now().isoformat()}
    
    è¿™æ˜¯ä¸€ä¸ªç”¨äºæµ‹è¯•RAGç³»ç»Ÿæ’å…¥åŠŸèƒ½çš„æ–‡æ¡£ã€‚
    
    å…³é”®ä¿¡æ¯ï¼š
    1. æµ‹è¯•æ—¶é—´: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
    2. æµ‹è¯•å…³é”®è¯: è“å¤©ç™½äº‘æ™´æœ—å¤©æ°”
    3. ç‰¹æ®Šæ ‡è¯†: MANUAL_TEST_DOC_12345
    
    å¦‚æœä½ èƒ½é€šè¿‡æŸ¥è¯¢æ‰¾åˆ°è¿™äº›å†…å®¹ï¼Œè¯´æ˜RAGæ’å…¥åŠŸèƒ½æ­£å¸¸å·¥ä½œã€‚
    """
    
    try:
        print("ğŸ§ª å¼€å§‹æ‰‹åŠ¨æµ‹è¯•RAGæ’å…¥åŠŸèƒ½...")
        
        # æ£€æŸ¥RAGæœåŠ¡çŠ¶æ€
        rag_healthy, rag_info = await check_rag_service_health()
        if not rag_healthy:
            return {
                "status": "error",
                "error": f"RAGæœåŠ¡ä¸å¯ç”¨: {rag_info}"
            }
        
        # æµ‹è¯•æ’å…¥
        payload = {"text": test_content}
        
        timeout = aiohttp.ClientTimeout(total=60)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            async with session.post(RAG_INSERT_URL, json=payload) as response:
                response_status = response.status
                response_text = await response.text()
                
                insert_result = {
                    "status": response_status,
                    "response": response_text[:500],
                    "success": response_status == 200
                }
                
                if response_status == 200:
                    print("âœ… æ‰‹åŠ¨æ’å…¥æµ‹è¯•æˆåŠŸ")
                    
                    # ç­‰å¾…ç´¢å¼•å®Œæˆ
                    await asyncio.sleep(3)
                    
                    # æµ‹è¯•æŸ¥è¯¢
                    query_result = await test_query_after_insert("è“å¤©ç™½äº‘æ™´æœ—å¤©æ°”")
                    
                    return {
                        "status": "success",
                        "test_content_length": len(test_content),
                        "insert_result": insert_result,
                        "query_result": query_result
                    }
                else:
                    print(f"âŒ æ‰‹åŠ¨æ’å…¥æµ‹è¯•å¤±è´¥: {response_status} - {response_text}")
                    return {
                        "status": "error", 
                        "insert_result": insert_result
                    }
        
    except Exception as e:
        print(f"âŒ æ‰‹åŠ¨æµ‹è¯•å¤±è´¥: {e}")
        return {
            "status": "error",
            "error": str(e)
        }

async def test_query_after_insert(query_text: str):
    """æ’å…¥åçš„æŸ¥è¯¢æµ‹è¯•"""
    try:
        payload = {"query": query_text, "mode": "naive"}
        
        timeout = aiohttp.ClientTimeout(total=30)
        async with aiohttp.ClientSession(timeout=timeout) as session:
            async with session.post(RAG_QUERY_URL, json=payload) as response:
                response_status = response.status
                response_text = await response.text()
                
                return {
                    "query": query_text,
                    "status": response_status,
                    "response": response_text[:500],
                    "success": response_status == 200,
                    "found_expected_content": "è“å¤©ç™½äº‘" in response_text or "MANUAL_TEST" in response_text
                }
    except Exception as e:
        return {
            "query": query_text,
            "error": str(e),
            "success": False
        }

if __name__ == "__main__":
    print("ğŸš€ å¯åŠ¨RAG Knowledge Management Web Interface")
    print("ğŸ“ è®¿é—®åœ°å€: http://localhost:4000") 
    print("ğŸ”— RAGæœåŠ¡åœ°å€: http://localhost:8001")
    print("ğŸ’¡ è¯·ç¡®ä¿å…ˆå¯åŠ¨ rag.py æœåŠ¡: python rag.py")
    uvicorn.run(app, host="0.0.0.0", port=4000)